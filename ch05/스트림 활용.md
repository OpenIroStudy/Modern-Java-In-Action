이 장의 내용  
* 필터링, 슬라이싱, 매칭
* 검색, 매칭, 리듀싱
* 특정 범위의 숫자와 같은 숫자 스트림 사용하기
* 다중 소스로부터 스트림 만들기
* 무한 스트림

<hr>

## 필터링
#### 1. Predicate로 필터링  
filter 메서드는 Predicate(boolean을 반환하는 함수)를 인수로 받아서 Predicate와 일치하는 모든 요소를 포함하는 스트림을 반환한다.  
``` java
   List<Dish> vegetarianMenu = Menu.menu.stream()
                .filter(Dish::isVegetarian) // 채식 요리인지 확인하는 메서드 참조
                .collect(Collectors.toList());
```  

#### 2. 고유 요소 필터링  
고유 요소로 이루어진 스트림을 반환한는 <b>distinct</b> 메서드도 지원한다.  
고유 여부는 스트림에서 만든 객체의 hashCode, equals로 결정됨.  
``` java
List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
        numbers.stream()
        .filter(i -> i % 2 == 0) // 짝수를 선택 2,2,4
        .distinct() // 중복 제거
        .forEach(System.out::println); // 2, 4
```  

## 슬라이싱
스트림의 요소를 선택하거나 스킵하는 다양한 방법이 있다.  
#### 1. Predicate를 이용한 슬라이싱
java9는 스트림의 요소를 효과적으로 선택할 수 있도록 takeWhile, dropWhile 두 가지 새로운 메서드를 지원한다.  

* takeWhile : 리스트가 정렬이 되어있을 때, filter 연산을 이용하면 전체 스트림을 반복하면서 각 요소에 predicate를 적용하게 된다.  
takeWhile은 predicate가 false가 나왔을 때 반복 작업을 중단할 수 있다.  
작은 리스트에서는 별거 아닐것처럼 보일 수 있지만 아주 많은 요소를 포함하는 스트림에서는 상당한 차이가 될 수 있다.  

``` java
List<Dish> sortedDishMenu =  Menu.getMenu().stream()
        .sorted(Comparator.comparing(Dish::getCalories)) // 칼로리가 낮은 순서대로 정렬
        .collect(Collectors.toList());

        List<Dish> slicedMenu1 = sortedDishMenu.stream()
                .takeWhile(dish->dish.getCalories()<320)
        .collect(Collectors.toList());

```  
* dropWhile : takeWhile의 정반대.  
predicate가 처음으로 거짓이 되는 지점까지 발견된 요소를 버림.  
거짓이 되면 그지점에서 작업을 중단하고 나머지 요소를 반환.  
dropWhile은 무한한 남은 요소를 가진 무한 스트림에서도 동작.  
``` java
List<Dish> slicedMenu2 = sortedDishMenu.stream()
                .dropWhile(dish->dish.getCalories()<320)
                .collect(Collectors.toList());
```  

#### 2. 스트림 축소 - limit
스트림은 주어진 값 이하의 크기를 갖는 새로운 스트림을 반환하는 limit(n) 메서드를 지원.  
스트림이 정렬되어 있어있지 않다면 limit의 결과도 정렬되지 않음.  
``` java
 List<Dish> slicedMenu3 = sortedDishMenu.stream()
                .filter(dish->dish.getCalories()>320)
                .limit(3)
                .collect(Collectors.toList());
```

#### 3. 요소 건너뛰기 - skip
스트림은 처음 n개 요소를 제외한 스트림을 반환하는 skip(n) 메서드를 지원한다.  
n개 이하의 요소를 포함하는 스트림에 skip(n)을 호출하면 빈 스트림이 반환한다.  
``` java
List<Dish> slicedMenu5 = Menu.getMenu().stream()
                .filter(d->d.getCalories() > 300)
                .skip(2).limit(2)
                .collect(Collectors.toList());
```  

## Mapping
특정 객체에서 특정 데이터를 선택할 수 있다.  
#### 1. map
함수를 인수로 받는 map 메서드는각요소에적용되며함수를 적용한 결과가새로운 요소로 매핑된다.  
예를 들면 Dish::getName을 map 메서드로 전달해 스트림의 요리명을 추출할 수 있다.  
``` java
 List<String> dishNames = Menu.getMenu().stream()
                .map(Dish::getName)
                .collect(Collectors.toList());
```  
getName은 문자열을 반환하므로 map 메서드의 출력 스트림은 String<String> 형식을 갖는다.  
   

``` java
// dish를 요리명으로 변환하고, 다시 요리명의 길이를 추출하는 예제
List<Integer> dishNameLength = Menu.getMenu().stream()
               .map(Dish::getName)
               .map(String::length)
               .collect(Collectors.toList());   
```  
   
#### 2. flatMap - 스트림의 평면화
flatMap은 각 요소를 스트림의 아니라 스트림의 콘텐츠로 매핑한다.  
스트림의 각 값을 다른 스트림으로 만든 다음에 모든 스트림을 하나의 스트림으로 연결하는 기능을 수행한다.  
![image](https://user-images.githubusercontent.com/67637716/162975984-f406f079-9fab-4bcf-8a0f-c6baf11dee6f.png)  
![image](https://user-images.githubusercontent.com/67637716/162976021-007a37e2-8472-493e-bc7c-7a00f2071498.png)  
 

#### quiz!!  
두 개의 숫자 리스트가 있을 때 모든 숫자 쌍의 리스트를 반환하시오.  
예를 들어 두 개의 리스트 [1,2,3]과 [3,4]가 주어지면 [(1,3),(1,4),(2,4),(3,3),(3,4)]를 반환해야 한다.  

``` java
List<Integer> num1 = Arrays.asList(1, 2, 3);
		List<Integer> num2 = Arrays.asList(3, 4);

		List<Stream<Integer[]>> s = num1.stream()
                                       .map(i -> num2.stream().map(j -> new Integer[] { i, j }))
				                           .collect(Collectors.toList());

		s.stream().forEach(d -> {
			System.out.println(d.map(arr -> Arrays.asList(arr)).collect(Collectors.toList()));
		});
---------------------------------------------------
   result : [[1, 3], [1, 4]]
            [[2, 3], [2, 4]]
            [[3, 3], [3, 4]]
   
   
		List<Integer[]> s2 = num1.stream()
                                  .flatMap(i -> num2.stream().map(j -> new Integer[] { i, j }))
                                  .collect(Collectors.toList());

		System.out.println(s2.stream().map(Arrays::asList).collect(Collectors.toList()));
---------------------------------------------------
   result : [[1, 3], [1, 4], [2, 3], [2, 4], [3, 3], [3, 4]]
```  
   
 ## 검색과 매칭
특정 속성이 데이터 집합에 있는지 여부를 검색하는 데이터 처리도 자주 사용됨.  
anyMatch, allMatch, noneMatch, findFirst, findAny 등 다양한 유틸리티 메서드를 제공.  

#### 1. anyMatch - predicate가 적어도 한 요소와 일치하는지 확인
``` java
if (Menu.getMenu().stream().anyMatch(Dish::isVegetarian))
            System.out.println("this is vegetarian friendly!!");
```  
anyMatch는 boolean을 반환하므로 최종 연산이다.  
	
#### 2. allMatch - predicate가 모든 요소와 일치하는지 검사
``` java
boolean isHealthy = Menu.getMenu().stream().allMatch(dish -> dish.getCalories() < 1000);	
```  

#### 3. noneMatch - allMatch와 반대연산, 주어진 predicate와 일치하는 요소가 없는지 확인.  
``` java
boolean isHealthy2 = Menu.getMenu().stream()
                .noneMatch(dish -> dish.getCalories() >= 1000);											
```  

* 쇼트 서킷
anyMatch, allMatch, noneMatch 세 메서드는 스트림 쇼트서킷 기법, 자바의 &&, || 와 같은 연산을 활용.  
and 표현식에서 하나라도 거짓이라는 결과가 나오면 나머지 표현식의 결과와 상관없이 전체 결과도 거짓이된다.  
이런 상황을 쇼트서킷이라 부름.  
원하는 요소를 찾았으면 즉시 결과를 반환할 수 있게 함.  
무한한 요소를 가진 스트림을 유한한 크기로 줄일 수 있는 유용한 연산.  
	
#### 4. findAny - 요소 검색
현재 스트림에서 임의의 요소를 반환.  
쇼트 서킷을 이용해서 결과를 찾는 즉시 리턴.  
``` java
Optional<Dish> dish = Menu.getMenu().stream()
                .filter(Dish::isVegetarian)
                .findAny();	
```  

#### 5. findFirst - 첫 번째 요소 찾기
정렬된 연속 데이터로부터 생성된 스트림에서 임의의 요소가 아닌 첫 번째 요소를 찾을 수 있다.  
``` java
// 숫자 리스트에서 3으로 나누어 떨어지는 첫 번째 제곱값을 반환하는 코드
List<Integer> someNumbers = Arrays.asList(1,2,3,4,5);
        Optional<Integer> firstElement = someNumbers.stream().map(n->n*n)
        		.filter(n -> n%3==0)
        		.findFirst();
        
        firstElement.ifPresent(System.out::println); // 9	
```  
findFirst는 병렬 실행에서는 첫 번째 요소를 찾기 어렵다.  
요소의 반환 순서가 상관없다면 병렬 스트림에서는 제약이 적은 findAny를 사용한다.  

* Optional
Optional<T> 클래스(java.util.Optional)는 값의 존재나 부재 여부를 표현하는 컨테이너 클래스(wrapper)  
findAny나 findFirst는 아무 요소도 반환하지 않을 수 있다.  
null은 쉽게 에러를 일으킬 수 있으므로 Optional<T>를 이용하여 null 확인 관련 버그를 피할 수 있다. (자세한 설명은 10장..)  
Optional은 값이 존재하는지 확인하고, 값이 없을 때 어떻게 처리할지 강제하는 기능을 제공한다.  
	* isPreset() : Optional이 값을 포함하면 true, 포함하지 않으면 false
	* ifPresent(Consumer<T> block) : 값이 있으면 주어진 block을 실행.  Consumer는 T형식의 인수를 받아 void를 반환.  
	* T get() : 값이 존재하면 반환하고 없으면 noSuchElementException을 일으킴
	* T orElse(T other) : 값이 있으면 반환하고, 없으면 기본값을 반환.
	


	


										
 
   
   
