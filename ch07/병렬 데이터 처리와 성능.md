# 병렬 데이터 처리와 성능
자바 7이 등장하기 전에는 데이터 컬렉션으 병렬로 처리하기가 어려웠다.
우선 데이터를 서브파트로 분할해야 한다. 그리고 분할된 서브파트를 각각의 스레드로 할당한다.
스레드로 할당한 다음에는 의도치 않은 레이스 컨디션(경쟁 상태)이 발생하지 않도록 적절한 동기화를 추가해야 하며,
마지막으로 부분 결과를 합쳐야 한다.

자바 7은 더 쉽게 병렬화를 수행하면서 에러를 최소화 할 수 있도록 포크/조인 프레임워크기능을 제공 한다.

## 병렬 스트림
스트림을 이용하면 순차 스트림을 병렬 스트림으로 자연스럽게 바꿀 수 있다.
자바 7에 추가된 포크/조인 프레임워크와 내부적인 병렬 스트림 처리는 어떤 관계가 있는지 살펴본다. 
병렬 스트림이 내부적으로 어떻게 처리되는지 알아야만 스트림을 잘못 사용하는 상황을 피할 수 있다.
컬렉션에 parallelStream을 호출하면 병렬 스트림이 생성된다. 
병렬 스트림이란 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림이다.
병렬 스트림을 이용하면 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있다.

### 순차 스트림을 병렬 스트림으로 변환
순차 스트림에 parallel 메서드를 호출하면 기존의 함수령 리듀싱 연산(숫자 합계 연산)이 병렬로 처리된다.

```
public long parallelSum(long n){
	return Stream.iterate(1L, i -> i + 1)
		     .limit(n)
		     .parallel() // 스트림을 병렬 스트림으로 변환
		     .reduce(0L, Long::sum);
}
```
순차 스트림에 parallel을 호출해도 스트림 자체에는 아무 변화도 일어나지 않는다.
내부적으로는 parallel을 호출하면 이후 연산이 병렬로 수행해야 함을 의미하는 불리언 플래그가 설정된다.
반대로 sequential로 병렬 스트림을 순차 스트림으로 바꿀 수 있다.
이 두 메서드를 이용해서 어떤 연산을 병렬로 실행하고 어떤 연산을 순차로 실행할지 제어할 수 있다.

```
stream.parallel()
      .filter(...)
      .sequential()
      .map(...)
      .parallel()
      .reduce();
```
parallel과 sequential 두 메서드 중 최종적으로 호출된 메서드가 전체 파이프라인에 영향을 미친다.
위 코드는 파이프라인의 마지막 호출은 parallel이므로 파이프라인은 전체적으로 병렬로 실행된다.

----------------
병렬 스트림은 내부적으로 ForkJoinPool을 사용한다. 

기본적으로 ForkJoinPool은 프로세서 수, 즉 Runtime.getRuntime().availableProcessors()가 반환하는 값에 상응하는 스레드를 갖는다.
----------------

### 스트림 성능 측정
성능을 최적화할 때는 세 가지 황금 규칙을 기억해야 한다.

1. 측정
2. 측정
3. 측정

** 반복 작업은 병렬로 수행할 수 있는 독립 단위로 나누기가 어렵다. **

병렬 프로그래밍을 오용(예를 들어 병렬과 거리가 먼 반복 작업)하면 오히려 전체 프로그램의 성능이 더 나빠질 수도 있다.

병렬화를 이용하기 위해선 특화된 메서드를 사용해야 한다.
특화되지 않은 스트림을 처리할 때는 오토박싱, 언박싱 등의 오버헤드를 수반하기 때문이다.
상황에 따라서는 어떤 알고리즘을 병렬화하는 것보다 적절한 자료구조를 선택하는 것이 더 중요하다는 사실을 단적으로 보여준다.

멀티코어 간의 데이터 이동은 우리 생각보다 비싸다.
따라서 코어 간에 데이터 전송 시간보다 훨씬 오래 걸리는 작업만 병렬로 다른 코어에서 수행하는 것이 바람직하다.
그리고 스트림을 병렬화해서 코드 실행 속도를 빠르게 하고 싶으면 항상 병렬화를 올바르게 사용하고 있는지 확인해야 한다.

### 병렬 스트림의 올바른 사용법
병렬 스트림을 잘못 사용하면서 발생하는 많은 문제는 공유된 상태를 바꾸는 알고리즘을 사용하기 때문에 일어난다.

```
public long sideEffectSum(long n){
	Accmulator acc = new Accmulator();
	LongStream.rangeClosed(1, n).forEach(acc::add);
	return acc.total;
}

public class Accmulator{
	public long total = 0;
	public void add(long value) {total += value;}
}
```
위 코드는 병렬로 실행하면 참사가 일어난다.
특히 total을 접근할 때마다 (다수의 스레드에서 동시에 데이터 접근하는) 데이터 레이스 문제가 일어난다.
동기화로 문제를 해결하다보면 결국 병렬화라는 특성이 없어져 버릴 것이다.

병렬화로 실행하면 여러 스레드에서 동시에 누적자, 즉 total += value를 실행하면서 이런 문제가 발생한다.

병렬 스트림을 사용했을 때 이상한 결과에 당황하지 않으려면 상태 공유에 따른 부작용을 피해야 한다.

### 병렬 스트림 효과적으로 사용하기
* 확신이 서지 않으면 직접 측정하라.
* 박싱을 주의하라.
* 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산이 있다. (특히 limit나 findFirst처럼 요소의 순서에 의존하는 연산)
* 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려하라.
* 소량의 데이터에서는 병렬 스트림이 도움 되지 않는다.
* 스트림을 구성하는 자료구조가 적절한지 확인하라.
* 스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질 수 있다.
* 최종 연산의 병합 과정 비용을 살펴보라.

![IMG_8344](https://user-images.githubusercontent.com/82895809/164273244-6ab2c394-7202-4c69-8333-37fa5f2152e3.jpg)




