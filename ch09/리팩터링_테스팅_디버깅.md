람다, 메서드 참조, 스트림을 활용해서 코드 가독성을 개선할 수 있는 간단한 세 가지 리팩터링 예제를 소개한다.

1 - 코드 가독성 개선  


2 - 익명 클래스를 람다 표현식으로 리팩터링
하나의 추상 메서드를 구현하는 익명 클래스는 람다 표현식으로 리팩터링

ex) Runnable 객체를 만드는 익명 클래스와 이에 대응하는 람다 표현식

```java
Runnable r1 = new Runnable() { // 익명클래스
    public void run() {
        System.out.println("Hello");
    }
};

// 람다표현식의 코드
Runnable r2 = () -> System.out.println("Hello");

```


하지만 모든 익명클래스를 변환할 수 있는것은 아니다.  
익명 클래스의 this, super는 람다 표현식에서 다음 의미.  
- 익명클래스에서 this 는 익명클래스 자신을 가리키지만, 람다에서 this 는 람다를 감싸는 클래스를 가리킴.
- 익명클래스는 감싸고있는 클래스의 변수를 가릴수 있음(섀도 변수), 람다에서는 변수를 가릴수 없음.

```java
int a = 10;

Runnable r1 = new Runnable() {
    public void run() {
        int a = 2; // 잘 동작.
        System.out.println(a);
    }
};

Runnable r2 = () -> {
    int a = 2; // 컴파일 에러.
    System.out.println(a);
}
```


- 익명클래스를 람다 표현식으로 바꾸면 콘텍스트 오버로딩에 따른 모호함 초래

```java
interface Task {
    public void execute();
}
public static void doSomething(Runnable r){ r.run(); }
public static void doSomething(Task a){ r.execute(); }

// Task를 구현하는 익명클래스 전달가능.
doSomething(new Task() {
    public void execute() {
        System.out.println("Danger danger!!");
    }
});

//하지만 익명클래스를 람다로 바꾸면 메서드 호출시 Runnable 과 Task 모두 대상형식이 되므로 모호함 발생.

doSomething(() -> System.out.println("Danger danger!!"));

//명시적 형변환으로 모호한 제거 가능.
doSomething((Task)() -> System.out.println("Danger danger!!"));
```

3- 람다 표현식을 메서드 참조로 리팩터링  
메서드 참조의 메서드 명으로 코드의 의도를 명확하게 알릴수 있음.  

ex) 6장의 칼로리 수준으로 요리 그룹화하는 코드

```java
Map<CaloricLevel, List<Dish>> dishesByCaloricLevel = menu.stream()
    .collect(
            groupingBy(dish -> {
                if(dish.getCalories() <= 400) return CaloricLevel.DIET;
                else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
                else return CaloricLevel.FAT;
            }));
            
// 람다표현식을 별도의 메서드로 추출한 후 groupingBy에 인수로 전달.
Map<CaloricLevel, List<Dish>> dishesByCaloricLevel = 
    menu.stream().collect(groupingBy(Dish::getCaloricLevel));
    
public class Dish {
    ...
    public CaloricLevel getCaloricLevel() {
        if(dish.getCalories() <= 400) return CaloricLevel.DIET;
        else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
        else return CaloricLevel.FAT;
    }
}
```

또한 comparing 과 maxBy 같은 정적 헬퍼 메서드를 활용하는 것도 좋다.


```java
// 비교구현에 신경써야함.
inventory.sort(
    (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));

// 코드가 문제 자체를 설명.
inventory.sort(comparing(Apple::getWeight));

``` 

* 함수형 인터페이스 적용 - 람다 표현식을 이용하려면 함수형 인터페이스가 필요

 
- 조건부 연기 실행

실제 작업을 처리하는 코드 내부에 제어 흐름문이 복잡하게 얽힌 코드를 종종 보임.
```java

if(logger.isLoggable(Log.FINER)) {
    logger.finer("Problem: " + generateDiagnostic());
}
```

- logger 상태가 isLoggable이라는 메서드에 의해 클라이언트 코드로 노출

- 메시지를 로깅할 때마나 logger객체 상태를 매번 확인해야 하므로 코드를 어지럽힘.
 
메시지를 로깅하기전에 logger객체가 적절한 수준으로 설정되었는지 내부적으로 확인하는 log메서드를 사용  

```java
logger.log(Level.FINER, "Problem: " + generateDiagnostic());
```

하지만 logger가 활성화 되지 않더라도 항상 로깅 메시지를 평가하게 되므로 람다를 이용해 문제를 해결.  

특정조건 에서만 메시지가 생성될 수 있도록 메시지 생성과정을 연기 할수 있게함.  

자바 8에서는 Supplier를 인수로 갖는 오버로드된 log 메서드 제공  

```java
// 새로 추가된 log 메서드의 시그니처
public void log(Level level, Supplier<String> msgSupplier)

// 다음과 같이 호출


// log 메서드는 logger의 수준이 적절하게 설정되어 있을때만 인수로 넘겨진 람다를 내부적으로 실행
public void log(Level level, Supplier<String> msgSupplier) {
    if(logger.isLoggable(level)) {
        log(level, msgSupplier.get());
    }
}

```


만일 클라이언트 코드에서 객체 상태를 자주 확인(logger 상태)하거나  

객체 일부 메서드를 호출하는 상황(메시지 로깅)이라면   

내부적으로 객체의 상태를 확인한 다음 메서드를 호출(람다나 메서드 참조를 인수로 사용)하도록  

새로운 메서드를 구현하는것이 좋다.  

코드의 가독성이 좋아질 뿐 아니라 캡슐화도 강화 (객체 상태가 클라이언트 코드로 노출되지 않음.)   

<br>
- 실행 어라운드 : 3장 참고


<br><br><br>
