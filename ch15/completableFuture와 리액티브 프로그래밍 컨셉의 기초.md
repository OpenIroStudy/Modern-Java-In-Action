##### CompletalbeFuture와 리액티브 프로그래밍 컨셉의 기초
- Thread, Future, 자바가 풍부한 동시성 API를 제공하도록 강요하는 진화의 힘
- 비동기 API
- 동시 컴퓨팅의 박스와 채널 뷰
- CompletableFuture 콤비네이터로 박스를 동적으로 연결
- 리액티브 프로그램용 자바 9 플로 api의 기초를 이루는 발행 구독 프로토콜
- 리액티브 프로그래밍과 리액티브 시스템


동시성과 병렬성  
<b> 동시성 </b> 은 단일 코어 머신에서 발생할 수 있는 프로그램잉 속성으로 실행이 겹칠 수 있는 반면    
<b> 병렬성 </b> 은 병렬 실행을 하드웨어 수준에서 지원한다.   
  
<br><br> 


처음에 자바는 Runnable과 Thread를 동기화된 클래스와 메스드를 이용해 잠갔다.    
자바5는 ExecutorService 인터페이스, 높은 수준의 결과 즉, Runnable, Thread의 변형을 반환하는 Callable<T> and Future<T>, 제너릭 등을 지원헀다.   
ExecutorService는 Runnable과 Callable 둘 다 실행할 수 있다.    
이런 기능 덕분에 멀티코어 CPU에서 쉽게 병렬 프로그래밍을 구현할 수 있게 되었다.   

```
  executorService 인터페이스는 Executor 인터페이스를 상속받으며 Callable을 실행하는 submit이라는 메서드를 포함한다. 
  Exector 인터페이스는 Runnable을 실행할 수 있는 execute 메서드만 포함한다. 
```
  
<br><br>
  
 멀티코어 CPU에서 효과적으로 프로그래밍을 실행할 필요성이 커지면서 이후 자바 버전에서는 개선된 동시성 지원이 추가되었다. 
자바 7에서는 분할 정복 알고리즘의 포크/조인 구현을 지원하는 RecursiveTask가 추가되었고 자바 8에서는 병렬 프로세싱이 추가되었다.   
  
  
  <br><br>
  
  
  
  병렬 스트림 반복은 명시적으로 스레드를 사용하는 것에 비해 높은 수준의 개념이라는 사실을 알 수 있다.    
  스트림을 이용해 스레드 패턴을 추상화할 수 있다.   
  쓸모 없는 코드가 라이브러리 내부로 구현되면서 복잡성도 줄어든다는 장점이 더해진다.   
  
  
  
  
  ###### Executor와 스레드풀
  
  - 스레드의 문제
  자바 스레드는 직접 운영체제 스레드에 접근한다.  
  운영체제 스레드를 만들고 종료하려면 비싼 비용을 치러야 하며 더욱이 운영체제 스레드의 숫자는 제한되어 있는 것이 문제다.  
  운영체제가 지원하는 스레드 수를 초과해 사용하면 자바 애플리케이션이 예상치 못한 방싯으로 크래시될 수 있으므로   
  기존 스레드가 실행되는 상태에서 계속 새로운 스레드를 만드는 상황이 일어나지 않도록 주의해야 한다. 
  
  
  
  <br><br><br>
  
  - 스레드 풀 그리고 스레드 풀이 더 좋은 이유  
  자바 ExecuorService는 태스크를 제출하고 나중에 수집할 수 있는 인터페이스를 제공한다.   
  newFixedThreadPool 같은 팩토리 메서드 중 하나를 이용해 스레드 풀을 만들어 사용할 수 있다.  
  
  ```java
  ExecutorService newFixedThreadPool(int nThreads)
  ```
  
  이 메서드는 워커 스레드라 불리는 nThreads를 포함하는 ExecutorService를 만들고 이들을 스레드 풀에 저장한다.         
  스레드 풀에서 사용하지 않은 스레드로 제출된 태스크를 먼저 온 순서대로 실행한다.   
  태스크 실행이 종료되면 이들 스레드를 풀로 반환한다.   
  - 장점 : 하드웨어에 맞는 수의 태스크를 유지함과 동시에 수 천개의 태스크를 스레드 풀에 아무 오버헤드 없이 제출할 수 있다는 점이다.    
  
  프로그래머는 태스크 (Runnable이나 Callable)를 제공하면 스레드가 이를 실행한다. 
  
  
  
    <br><br><br>
  
  - 스레드 풀 그리고 스레드 풀이 나쁜이유
  
  k스레드를 가진 스레드 풀은 오직 k만큼의 스레드를 동시에 실행할 수 있다. 초과로 제출된 테스크는 큐에 저장되며   
  이전의 캐스크 중 하나가 종료되기 전까지는 스레드에 할당하지 않는다.   
    
  
  
