수년 전까지 대규모 애플리케이션은 수십 대의 서버 , 기가바이트의 데이터, 수초의 응답 시간, 몇 시간의 유지보수 시간 등의 특징을 가졌다.  
오늘날에는 다음과 같은 적어도 세 가지 이유로 상황이 변하고 있다.  
* 빅 데이터 : 보통 빅데이터는 페타바이트 단위로 구서오디며 매일 증가.  
* 다양한 환경 : 모바일 디바이스에서부터 수천개의 멀티코어 프로세서로 실행되는 클라우드 기반 클러스터에 이르기까지 다양한 환경에 애플리케이션 배포  
* 사용 패턴 : 1년 내내 항상 서비스를 이용할 수 있으며, 밀리초 단위의 응답 시간을 기대

예전 소프트웨어 아키텍처로는 이런 요구사항을 만족시킬 수 없었다.  
인터넷 트래픽을 가장 많이 일으키는 디바이스가 모바일인 요즘은 이런 양상이 두드러지고 있으며 사물인터넷(IOT) 같은 기기들로 가까운 미래에는 상황이 더욱 심화될 것이다.  
※ IOT: 다른 사물과 데이터를 송수신할 수 있는 센서와 소프트웨어, 기타 기술을 장착하고 서로 연결된 사물  

<br>
리액티브 프로그래밍에서는 다양한 시스템과 소스에서 들어오는 데이터 항목 스트림을 <b>비동기적으로 처리하고 합처서</b> 이런 문제를 해결.  
이런 패러다임에 맞게 설계된 애플리케이션은 발생한 데이터항목을 바로 처리함으로써 사용자에게 높은 응답성 제공.  


# 리액티브 매니패스토  
리액티브 매니패스토(https://www.reactivemanifesto.org/)는 리액티브 애플리케이션과 시스템 개발의 핵심 원칙을 공식적으로 정의.  

* 반응성(responsive) 
  * 리액티브 시스템은 빠를 뿐 아니라 더 중요한 특징으로 일정하고 예쌍할 수 있는 반응 시간 제공.  
  * 사용자에게 신뢰성 있는 빠른 응답을 제공하는 것을 의미

* 회복성(resilient)
  * 장애가 발생해도 시스템은 반응해야한다.  
  * 회복성을 달성할 수 있는 다양한 기법 제시
  * 회복력이 있다는 것은 장애가 발생하더라도 , 부분적으로 고장이 나더라도 전체가 고장 나지 않고 빠르게 복구하는 능력을 의미한다.

* 탄력성(elastic)
  * 애플리케이션의 생명주기 동안 다양한 작업 부하로 반응성이 위협받을 수 있다.  
  * 무서운 작업 부하가 발생하면 자동으로 관련 컴포넌트에 할당된 자원 수를 늘림.

* 메시지 주도(Message-driven)
  * 회복성과 탄력성을 지원하려면 약한 결합, 고립, 위치 투명성등을 지원할 수 있도록 시스템을 구성하는 컴포넌트의 경계를 명확하게 정의해야함
  * 비동기 메시지를 전달해 컴포넌트끼리의 통신이 이루어짐
  * 회복성(장애를 메시지로 처리)과 탄력성(주고 받은 메시지의 수를 감시하고 메시지의 양에 따라 적절하게  리소스를 할당)을 얻을 수 있다.  
  * 비동기 메시지 전달을 통해 위치 투명성 느슨한 결합 ,논 블로킹 통신을 지향

![image](https://user-images.githubusercontent.com/67637716/168417406-a1efd4be-afbe-44bc-a936-d709b1b7c37a.png)  

4가지 요소는 모두 reactive (반응이 빠른) 시스템을 만들기 위한 요소들이고 각 요소들은 상호 보완적이다.  


### 애플리케이션 수준의 리액티브  
애플리케이션 수준 컴포넌트의 리액티브 프로그래밍의 기능은 비동기로 작업을 수행할 수 있다는 점이다.  
자바 개발자에게 동시성 = 많은 쓰레드 였다.  
쓰레드 별로 다른 일을 하도록하면 쓰레드 갯수만 늘리면 동시에 여러 일을 처리하게 할 수 있었으니까.  
그런데 시스템이 점점 분산되고(MSA) API 호출, 데이터 액세스등의 이유로 IO 수행시간이 늘어났다.(=쓰레드 점유)  
<br>
많은 쓰레드로 해결을 할 때는 몇가지 문제가 있다.  
CPU와 메모리가 충분해도 쓰레드가 부족하면 처리율이 내려가고, 쓰레드를 늘리면 CPU와 메모리에 엄청난 부하가 간다.  
쓰레드를 변경할 때 사용되는 비용이 CPU 에 부하를 주기때문에 이 역시 문제다. 쓰레드는 그래서 상대적으로 비싸고 희귀한 자원이다.  
<br>
리액티브 프레임워크와 라이브러리는 쓰레드를 퓨처, 액터, 일련의 콜백을 발생시키는 이벤트 루프등과 공유하고 처리할 이벤트를 변환하고 관리한다. 이 기술은 쓰레드보다 가볍다 🕊 !

거기에 별도로 지정된 스레드 풀에서 블록 동작을 실행시켜서, 스레드 블록의 문제를 해결한다.  
메인 풀의 모든 스레드는 방해받지 않고 실행되므로 가장 최적의 상황에서 동작할 수 있다.  
비교적 짧은 시간 동안만 유지되는 데이터 스트림에 기반한 연산을 수행하며 보통 이벤트 주도로 분류.  



### 시스템 수준의 리액티브
리액티브 시스템은 여러 애플리케이션이 하나의 일관적이며 회복이 가능한 플랫폼을 구성해주는 아키텍처를 말한다.  
시스템 수준에서는, 애플리케이션을 조립하고 상호 소통을 조절한다. 이런 과정에는 메시지 주도 (message-driven) 이 사용된다.  


메시지는 정의된 목적지 하나만 바라보고 가는 반면, 이벤트는 옵저버들이 모두 수신한다는게 다른점이다.  
리액티브 시스템에서는 수신자, 발신자가 수신 메시지와 발신 메시지와 강하게 결합하지 않고, 독립적인 구조를 유지하도록 메시지를 비동기로 처리한다.  

그래야 시스템이 (장애로부터의) 회복성 ,(높은 부하로부터의) 탄력성 에서도 반응성을 유지할 수 있다.  
<br>


시스템에서 장애가 발생했을 때, 리액티브 시스템은 성능이 저하되는 것이 아니라 문제를 완전히 고립시켜서 시스템을 복구한다.  
예를 들어 에러 전파를 방지하고, 메시지 방향성을 바꾸어 다른 컴포넌트로 보내는 등 감독자 역할을 수행해서 문제를 고립시킬 수 있다.  
이렇게 하여, 컴포넌트 자체로 문제가 한정되고, 외부로는 안정성을 보장할 수 있다.  

회복성은 고립, 비결합 이 핵심이다.  
그리고 탄력성의 핵심은 위치 투명성이다 위치 투명성은 리액티브 시스템의 모든 컴포넌트가 다른 모든 서비스와 통신할 수 있음을 의미한다.  
위치에 상관없이 모두 서로 통신이 가능하기때문에 시스템을 복제할 수 있으며, 작업 부하에 따라 자동으로 애플리케이션을 확장할 수 있다.  

※ 동기, 비동기, 블락킹, 논블라킹 : https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC  

![image](https://user-images.githubusercontent.com/67637716/168418853-dcbfec9b-e463-44ef-a55f-5b0eeb896a31.png)

