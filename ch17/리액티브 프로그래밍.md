수년 전까지 대규모 애플리케이션은 수십 대의 서버 , 기가바이트의 데이터, 수초의 응답 시간, 몇 시간의 유지보수 시간 등의 특징을 가졌다.  
오늘날에는 다음과 같은 적어도 세 가지 이유로 상황이 변하고 있다.  
* 빅 데이터 : 보통 빅데이터는 페타바이트 단위로 구서오디며 매일 증가.  
* 다양한 환경 : 모바일 디바이스에서부터 수천개의 멀티코어 프로세서로 실행되는 클라우드 기반 클러스터에 이르기까지 다양한 환경에 애플리케이션 배포  
* 사용 패턴 : 1년 내내 항상 서비스를 이용할 수 있으며, 밀리초 단위의 응답 시간을 기대

예전 소프트웨어 아키텍처로는 이런 요구사항을 만족시킬 수 없었다.  
인터넷 트래픽을 가장 많이 일으키는 디바이스가 모바일인 요즘은 이런 양상이 두드러지고 있으며 사물인터넷(IOT) 같은 기기들로 가까운 미래에는 상황이 더욱 심화될 것이다.  
※ IOT: 다른 사물과 데이터를 송수신할 수 있는 센서와 소프트웨어, 기타 기술을 장착하고 서로 연결된 사물  

<br>
리액티브 프로그래밍에서는 다양한 시스템과 소스에서 들어오는 데이터 항목 스트림을 <b>비동기적으로 처리하고 합처서</b> 이런 문제를 해결.  
이런 패러다임에 맞게 설계된 애플리케이션은 발생한 데이터항목을 바로 처리함으로써 사용자에게 높은 응답성 제공.  


# 리액티브 매니패스토  
리액티브 매니패스토(https://www.reactivemanifesto.org/)는 리액티브 애플리케이션과 시스템 개발의 핵심 원칙을 공식적으로 정의.  

* 반응성(responsive) 
  * 리액티브 시스템은 빠를 뿐 아니라 더 중요한 특징으로 일정하고 예쌍할 수 있는 반응 시간 제공.  
  * 사용자에게 신뢰성 있는 빠른 응답을 제공하는 것을 의미

* 회복성(resilient)
  * 장애가 발생해도 시스템은 반응해야한다.  
  * 회복성을 달성할 수 있는 다양한 기법 제시
  * 회복력이 있다는 것은 장애가 발생하더라도 , 부분적으로 고장이 나더라도 전체가 고장 나지 않고 빠르게 복구하는 능력을 의미한다.

* 탄력성(elastic)
  * 애플리케이션의 생명주기 동안 다양한 작업 부하로 반응성이 위협받을 수 있다.  
  * 무서운 작업 부하가 발생하면 자동으로 관련 컴포넌트에 할당된 자원 수를 늘림.

* 메시지 주도(Message-driven)
  * 회복성과 탄력성을 지원하려면 약한 결합, 고립, 위치 투명성등을 지원할 수 있도록 시스템을 구성하는 컴포넌트의 경계를 명확하게 정의해야함
  * 비동기 메시지를 전달해 컴포넌트끼리의 통신이 이루어짐
  * 회복성(장애를 메시지로 처리)과 탄력성(주고 받은 메시지의 수를 감시하고 메시지의 양에 따라 적절하게  리소스를 할당)을 얻을 수 있다.  
  * 비동기 메시지 전달을 통해 위치 투명성 느슨한 결합 ,논 블로킹 통신을 지향

![image](https://user-images.githubusercontent.com/67637716/168417406-a1efd4be-afbe-44bc-a936-d709b1b7c37a.png)  

4가지 요소는 모두 reactive (반응이 빠른) 시스템을 만들기 위한 요소들이고 각 요소들은 상호 보완적이다.  


### 애플리케이션 수준의 리액티브  
애플리케이션 수준 컴포넌트의 리액티브 프로그래밍의 기능은 비동기로 작업을 수행할 수 있다는 점이다.  
자바 개발자에게 동시성 = 많은 쓰레드 였다.  
쓰레드 별로 다른 일을 하도록하면 쓰레드 갯수만 늘리면 동시에 여러 일을 처리하게 할 수 있었으니까.  
그런데 시스템이 점점 분산되고(MSA) API 호출, 데이터 액세스등의 이유로 IO 수행시간이 늘어났다.(=쓰레드 점유)  
<br>
많은 쓰레드로 해결을 할 때는 몇가지 문제가 있다.  
CPU와 메모리가 충분해도 쓰레드가 부족하면 처리율이 내려가고, 쓰레드를 늘리면 CPU와 메모리에 엄청난 부하가 간다.  
쓰레드를 변경할 때 사용되는 비용이 CPU 에 부하를 주기때문에 이 역시 문제다. 쓰레드는 그래서 상대적으로 비싸고 희귀한 자원이다.  
<br>
리액티브 프레임워크와 라이브러리는 쓰레드를 퓨처, 액터, 일련의 콜백을 발생시키는 이벤트 루프등과 공유하고 처리할 이벤트를 변환하고 관리한다. 이 기술은 쓰레드보다 가볍다 🕊 !

거기에 별도로 지정된 스레드 풀에서 블록 동작을 실행시켜서, 스레드 블록의 문제를 해결한다.  
메인 풀의 모든 스레드는 방해받지 않고 실행되므로 가장 최적의 상황에서 동작할 수 있다.  


