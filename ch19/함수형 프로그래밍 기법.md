# 함수형 프로그래밍 기법
## 고차원 함수
지금까지 함숫값을 자바 8 스트림 처리 연산으로 전달하거나 filterApples에 함숫값으로 Apple::isGreenApple을 전달해서 동작 파라미터화를 달성하는 용도로만 사용했다.

이는 함숫값 활용의 일부에 불과하다.

함수를 인수로 받아서 다른 함수로 변환하는 정적 메서드도 있었다.
```
Comparator<Apple> c = comparing(Apple::getWeight);
```

함수형 프로그래밍 커뮤니티에 따르면 Comparator.comparing 처럼 다음 중 하나 이상의 동작을 수행하는 함수를 고차원 함수라고 부른다.
* 하나 이상의 함수를 인수로 받음
* 함수를 결과로 반환

자바 8에서는 함수를 인수로 전달할 수 있을 뿐 아니라 결과로 반환하고, 지역 변수로 할당하거나, 구조체로 삽입할 수 있으므로 자바 8의 함수도 고차원 함수라고 할 수 있다.

## 영속 자료구조
함수형 프로그램에서는 함수형 자료구조, 불변 자료구조 등의 용어도 사용하지만 보통은 영속 자료구조라고 부른다.
(여기서 영속은 DB에서 프로그램 종료 후에도 남아있음을 의미하는 영속과는 다른 의미이다.)

함수형 메서드에서는 전역 자료구조나 인수로 전달된 구조를 갱신할 수 없다.

자료구조를 바꾼다면 같은 메서드를 두 번 호출했을 때 결과가 달라지면서 참조 투명성에 위배되고 인수를 결과로 단순하게 매핑할 수 있는 능력이 상실되기 때문이다.

### 파괴적인 갱신과 함수형
자료구조를 갱신할 때 발생할 수 있는 문제.

A -> B 까지 기차여행을 의미하는 가변 TrainJourney 클래스가 있다.

TrainJourney는 간단한 단방향 연결 리스트로 구현되며 여행 구간의 가격 등 상세 정보를 포함하는 int 필드를 포함한다.

또 여러 TrainJourney 객체를 연결할 수 있는 onward(이어지는 여정을 의미)라는 필드가 필요하다.

직통열차나 여정의 마지막 구간에서는 onward가 null이 된다.
```
class TrainJourney {
	public int price;
	public TrainJourney onward;

	public TrainJourney(int p, TrainJourney t) {
		price = p;
		onward = t;
	}
}
```
이떄 X에서 Y까지 그리고 Y에서 Z까지의 여행을 나타내는 별도의 TrainJourney 객체가 있다고 가정하자.

두 개의 TarinJourney 객체를 연결해서 하나의 여행을 만들 수 있을 것이다.

```
static TrainJourney link(TrainJourney a, TrainJourney b) {
	if (a == null)
		return b;

	TrainJourney t = a;
	while (t.onward != null) {
		t = t.onward;
	}
	t.onward = b;
	return a;
}
```
위 코드는 a의 TrainJourney에서 마지막 여정을 찾아 a의 리스트 끝부분을 가리키는 null을 리스트 b로 대체한다.

여기서 문제가 발생한다. firstJourney라는 변수는 X에서 Y로의 경로를 포함하고, secondJourney라는 변수는 Y에서 Z로의 경로를 포함한다.

link(firstJourney, secondJourney)를 호출하면 firstJourney가 secondJourney를 포함하면서 파괴적인 갱신(즉, firstJourney를 변경시킴)이 일어난다.

결과적으로 firstJourney 변수는 X에서 Y로의 여정이 아니라 X에서 Z로의 여정을 의미하게 된다.

이렇게 되면 firstJourney에 의존하는 코드가 동작하지 않게 된다.

함수형에서는 이 같은 부작용을 수반하는 메서드를 제한하는 방식으로 문제를 해결한다.

계산결과를 표현할 자료구조가 필요하면 기존의 자료구조를 갱신하지 않도록 새로운 자료구조를 만들어야 한다.

이는 표준 객체지향 프로그래밍의 관점에서도 좋은 기법이다.

```
static TrainJourney append(TrainJourney a, TrainJourney b) {
	return a == null ? b : new TrainJourney(a.price, append(a.onward, b));
}
```
이 코드는 명확하게 함수형이며 기존 자료구조를 변경하지 않는다.

함수형 자료구조를 영속(저장된 값이 다른 누군가에 의해 영향을 받지 않는 상태)이라고 한다.

'결과 자료구조를 바꾸지 말라'는 것이 자료구조를 사용하는 모든 사용자에게 요구하는 단 한 가지 조건이다.

## 커링
커링은 x와 y라는 두 인수를 받는 함수 f를 한 개의 인수를 받는 g라는 함수로 대체하는 기법이다.

이때 g라는 함수 역시 하나의 인수를 받는 함수를 반환한다.

함수 g와 함수 f가 최종적으로 반환하는 값은 같다.

<img width="627" alt="image" src="https://user-images.githubusercontent.com/82895809/169765435-84488654-7065-4bee-9cb4-9c4c01b6d690.png">

이와 같은 여러 과정이 끝까지 완료되지 않은 상태를 가리켜 '함수가 부분적으로 적용되었다'라고 말한다.

> 수학과 컴퓨터 과학에서 커링(currying)이란 다중 인수(혹은 여러 인수의 튜플)을 갖는 함수를 단일 인수를 갖는 함수들의 함수열로 바꾸는 것을 말한다.

## 콤비네이터
함수형 프로그램이에서는 두 함수를 인수로 받아 다른 함수를 반환하는 등 함수를 조합하는 고차원 함수를 많이 사용하게 된다.

이처럼 함수를 조합하는 기능을 콤비네이터라고 부른다.

자바 8 API에 추가된 많은 기능은 콤비네이터의 영향을 받았다.

예를 들어 CompletableFuture 클래스에는 thenCombine() 이라는 메소드가 추가되었다.

thenCombine() 메소드는 CompletableFuture와 BiFunction 두 인수를 받아 새로운 CompletableFuture를 생성한다.

이 개념을 활용하면 반복 과정에서 전달되는 가변 상태 함수형 모델 등 반복 기능을 좀 더 다양하게 활용할 수 있다.

* 일급 함수란 인수로 전당하거나, 결과로 반환하거나, 자료구조에 저장할 수 있는 함수다.
* 고차원 함수란 한 개 이상의 함수를 인수로 받아서 다른 함수를 반환하는 함수다. 자바에서는 comparing, andThen, compose 등 고차원 함수를 제공한다.
* 커링은 함수를 모듈화하고 코드를 재사용할 수 있도록 지원하는 기법이다.
* 영속 자료구조는 갱신될 때 기존 버전의 자신을 보존한다. 결과적으로 자신을 복사하는 과정이 따로 필요하지 않다.
* 자바의 스트림은 스스로 정의할 수 없다.
* 게으른 리스트는 자바 스트림보다 비싼 버전으로 간주할 수 있다. 게으른 리스트는 데이터를 요청했을 때 Supplier를 이용해서 요소를 생성한다. Supplier는 자료구조의 요소를 생성하는 역할을 수행한다.
* 패턴 매칭은 자료형을 언랩하는 함수형 기능이다. 자바의 switch문을 일반화할 수 있다.
* 참조 투명성을 유지하는 상황에서는 계산 결과를 캐시할 수 있다.
* 콤비네이터는 둘 이상의 함수나 자료구조를 조합하는 함수형 개념이다.
